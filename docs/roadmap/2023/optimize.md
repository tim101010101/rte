# 重构激活逻辑

- [ ] 重构激活逻辑, 并非插入 prefix 和 suffix, 而是将 text 替换为 source 源代码

主要好处在于

1. 省去很多复杂的逻辑
2. 保持与 block 激活的一致性
3. 优化性能

很关键的一点, 现在 line 的实现为了将 prefix 和 suffix 与内容视为整体做了很多特殊处理, 花了很多功夫

而如果将激活逻辑改为之前更改 text 的话, prefix 和 suffix 和节点内容天然就是整体

block 的激活希望能显示源代码, 以此来获取更好的编辑体验, 那么 line 和 block 的激活思路保持一致的话, 有利于工具函数的复用

而性能方面, 只是更换 textNode 的 text 而已, 影响范围很有限, 有利于 patch

具体的, 激活始终只会影响被激活节点, 其余部分已经被渲染的结果可以一定程度的复用, 这里不考虑长度改变产生 DOM 节点的位移

这个重构的影响范围不大, 但是可能会影响到 fence、vNode 的结构, 因此还是先重构完再来继续做 block

## 补档

这个重构涉及到扁平化 VNode, 其实是一个触及根基的重构, 我确实小看这个重构了

经过思索和推演, 发现扁平化 vNode 的方式, 有以下劣势

- 无法很好的将 marker 和 content 视为一个整体, 无法表示这种嵌套的整体结构
- 破坏了渲染层的纯度, fence 依赖 render 返回结果

因此考虑将结合现有架构以及 canvas 渲染, 重构为 canvas 渲染, 再在 canvas 渲染的基础上, 对激活逻辑进行简化

具体的

**fence 可以保存 marker 信息, 而通过 behavior 以及 isActive 来控制是否渲染**

# 重构 fence

- [ ] 重构 fence, 合并激活与未激活的情况

好处在于

1. 减少 calcFence 的计算频率, 只有内容发生更改才需要进行计算

问题在于

fenceItem 需要保存光标偏移, 这个会随着激活状态发生改变, 若是非得要同时支持激活与非激活, 就需要在 patch 时同时计算出激活和未激活时的 rectList

这样来看的话, 这个想法就不一定价值很大了, 因为增加了 patch 的运算量, 并且如果提前计算出未激活时的状态, 那何不直接缓存起来, 而这个缓存会存在很大的内存消耗, 相当于这里的运行时内存消耗翻了一倍以上

# eventBus 重构

目前的 eventBus, 通过对 listener 做代理来判断点击事件是否触发, 这样的时间复杂度是 O(N), 而成型后, 运行时会存在大量 listener, 这样的时间复杂度无法接受

导火索是实现点击插入光标的逻辑, 存在两种思路, 但都不够优秀

1. 给 Operable 添加 addEventListener 方法, 让每个 Operable 自己管理点击事件
   - 好处, 实现起来比较好看, 事件的管理比较统一
   - 坏处, 按照目前的事件实现思路, 判断是否触发需要 O(N), 而且这个 N 指的是回调的数量
2. 监听 window 的点击事件, 由 page 来管理点击插入光标的逻辑
   - 好处, 无论是定位 listView 还是获取 offset 都可以用二分查找优化, O(logN)
   - 坏处, 事件管理不够统一, 事件这里一个那里一个的很恶心

因此出于可维护性考虑, 决定对 eventBus 做重构优化

主要针对事件底层的存储结构, 也就是现在的 `EventBus::_events`, 目前是一个哈希表, listener 是一个普通数组

设想维护一个有序数组或者构建一棵特殊的树来使其支持二分查找

这样可以把判断点击事件是否触发的时间复杂度优化到 O(logN + M), N 为 listener 的总数, M 为需要被触发的 listener 数量, 算是比较优秀的了

但是暂时还没构思好, 先存着 idea
