# 2023-1-5

昨天遗留的问题是这样的

```text
a|bcd    offset = 1     <input '*'>

a*|bcd   offset = 2     <input '*'>

a*b*|cd  offset = 4     <move right>    <cancel active>

abc|d    offset = 3     <input 'e'>     <update>

textContentWithMarker = "a*b*cd"
               offset = 3

<insertAt>

newTextContent = "a*be*cd"

!!!ERROR HERE
```

1. 直接设置多一个取消激活之前的 offset, 应该是可以直接解决, 值得这么做么
2. 在 fence 做处理, 让其携带 marker 信息

## 补档

暂时直接写了个暴力算法计算实际的 offset, 嘿嘿, 实际上应该是在 fence 中添加一个 offsetWithMarker 比较好, 但是暂时不打算改动 fence, 因为可能会重构

## 一个 bug

表现为点击一个未被激活的 syntax 时, 激活 syntax 后, 光标会产生偏移, 偏移为 marker 长度, 这个是预期之中的

但是此时再点击已经被激活的 syntax, 仍然会存在偏移

```text
**hello** world    <render>

hello world        <click offset = 1>

**h|ello** world   <click offset = 3>

**hel|lo** world

ERROR
```

原因在于

page 的 focusOn 之中会直接调用 selection 的 focusOn

第一次点击激活时 offset 为 1, 此时激活节点, offset 变成 3

再次点击 offset 为 3 的位置, focusOn(3) 会忽略 marker 节点, 而直接 focus 到 syntax 内容的 3 的位置

这个应该是 fence 的问题, 猜测是因为 fence 没有考虑 marker

不对啊, fence 是考虑了 marker 的

那么原因就是因为 switchActive

果然, 因为 switchActive 里面优先取消了节点的激活, 之后再重新设置光标, 因此点击时, 光标位置总会忽略 marker

## 补档

修好了, 根据 prevPos 和 curPos 自己计算 isCorssLine, 而不硬编码在 clickhandler 中就可以了, 顺便还减少了函数参数和冗余代码

## 一个 bug

接下来这个 bug 是, 行尾是个 syntax, 点击激活后, 再点击行尾空白会报错 out of bound

草, 搞错了

行尾是个 text, 前面是个 syntax, 这时点击行尾空白会 out of bound
