# 2023-6-27

如何组织步长、帧数

requestAnimateFrame 是每帧执行一次

会给回调传入一个 timestamp 表示当前回调触发时间, 是和 `performance.now()` 一样的精度

而这个回调会按照屏幕的刷新率，每帧执行一次，比如 mac 是 120hz，1s 执行 120 次，window 是 144hz，1s 执行 144 次

滚动事件的触发频率很高，并且频率不好控制，最好做一个节流限制触发间隔

那么就又衍生出一个问题

- 如果做节流的话，如何保证慢速滚动和快速滚动的丝滑

## 关于慢速滚动和快速滚动

其实应该没有区别，快速滚动也需要有速度上限，也就是说需要受到节流的控制，慢速滚动就理解为没达到节流限制的滚动频率

所以应该不需要考虑这个问题

## 想法

滚动事件每触发一次，应该占用多少帧呢

一种思路是，节流限制一帧触发一次，那么也就意味着每个滚动事件最多占用一帧

但是这样有一个问题，我们的目标仅仅只是 60 帧，大于 60 帧的计算都是浪费性能

那么要怎么保证兼容不同显示器的 60 帧均匀刷新率呢

所谓均匀刷新率，其实是需要将 60 次渲染任务均匀分配到 1s 的时间内

也就是说可以将节流参数控制在 `(60 / 1000) ms`, 并在一次触发时，请求一个时间片进行刷新，只需要保证这段时间内重渲染一次就可以了

经过测试没问题，非常丝滑，但是出现了一个核心问题，如果这样的话，每次移动的步长总是恒定的，会导致元素不跟手

也就是说需要设计一个足够跟手的滚动算法
