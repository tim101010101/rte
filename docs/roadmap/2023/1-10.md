# 2023-1-10

fence 该长什么样

比如针对下面的 line

```typescript
const line = {
  text: '**a _b_**c',
  ranges: [
    {
      id: 1,
      range: [0, 1],
      fontInfo: {},
      behavior: { beforeActive: { show: false } },
    },
    {
      id: 1,
      range: [2, 3],
      fontInfo: {},
    },
    {
      id: 1,
      range: [4, 4],
      fontInfo: {},
      behavior: { beforeActive: { show: false } },
    },
    {
      id: 1,
      range: [5, 5],
      fontInfo: {},
    },
    {
      id: 1,
      range: [6, 6],
      fontInfo: {},
      behavior: { beforeActive: { show: false } },
    },
    {
      id: 1,
      range: [7, 8],
      fontInfo: {},
      behavior: { beforeActive: { show: false } },
    },
    {
      id: 2,
      range: [9, 9],
      fontInfo: {},
    },
  ],
};
```

首先最好将 id 相同的部分合并

```typescript
const fence = [
  {
    id: 1, // '**a _b_**'
  },
  {
    id: 2, // 'c'
  },
];
```

其实有很多种方式来保存可插入光标的位置, 最简单的就是每个节点保存一个 fenceList, 每一项表示一个光标位置, 并保存 fontInfo, cursorOffset, textOffset

```typescript
const fence = [
  {
    id: 1,
    fenceList: [
      { fontInfo: {}, cursorOffset: 0, textOffset: 0, behavior: {} },
      { fontInfo: {}, cursorOffset: 1, textOffset: 1, behavior: {} },
      // ...
    ],
  },
];
```

如果是这样的话, 为什么不直接用原本的 line

渲染信息也可以用 fence 的形式, 不如说我觉得以 fence 的形式来传递渲染信息会更加好

直接遍历 range, 一个 range 一个 range 的渲染, 渲染之前使用 behavior 里的配置覆盖 fontInfo

具体的, 遍历 ranges 时, 当前是未激活状态, 遍历到第一个 range, 发现其 beforeActive 的 show 是 false, 直接跳过这个 range

也许可以在这一步同时渲染光标, 因为光标的渲染需要文本宽度

```typescript
const fence = [
  text: '**a _b_**c',
  ranges: [
    {
      id: 1,
      range: [0, 1],
      fontInfo: {},
      behavior: { beforeActive: { show: false } },
    },
    {
      id: 1,
      range: [2, 3],
      fontInfo: {},
    },
    {
      id: 1,
      range: [4, 4],
      fontInfo: {},
      behavior: { beforeActive: { show: false } },
    },
    // ...
  ],
];
```

现在很关键的一点在于, 何时获取字符宽度, 这个很重要, 因为不管是点击插入光标需要, 要不就让 fence 在渲染后返回, 由其计算出 fence

那么 fence 中就只保存确实渲染出来了的结果, 以此作为插入光标的指导

## 关于 fence

需要保存以下信息

- 光标位置
- node id
- rect

由 render 返回, 只保存实际渲染出来了的部分

那么如何根据 fence 激活节点呢

block 中保存当前激活的 id, 光标命中时, 判断当前节点是否已经被激活

那么 fence 也需要特殊处理, 因为 syntax 的首尾都能够激活节点

比如 `**a _b_**` 正常渲染成 `a b`, fence 中应该有 0-3 总共 4 项

无论命中这个节点中的什么位置, 都应该对其进行激活, 并把 id 保存起来

然后重新渲染

然后重新设置光标位置, 这里需要能够获取节点激活前后的位移

### 关于激活节点后的光标偏移

比如 `**a _b_**` 正常渲染成 `a b`

以下几种情况

- `|a b` => `|**a _b_**`
- `a| b` => `**a| _b_**`
- `a |b` => `**a |_b_**`
- `a b|` => `**a _b_**|`

也就是说, 需要对首尾部分特殊处理, 具体的

- 头部: 不变
- 尾部: 增加原本不显示的 piece 的总长度

再复杂一点的呢

`**a _b_ c**`, 正常渲染成 `a b c`

- `|a b c` => `|**a _b_ c**`
- `a| b c` => `**a| _b_ c**`
- `a |b c` => `**a |_b_ c**`
- `a b| c` => `**a _b_| c**` 这里有问题
- `a b |c` => `**a _b_ |c**`
- `a b c|` => `**a _b_ c**|`

`a b| c` => `**a _b_| c**` 这种场景无法处理, 因为无法得知 b 的后面还有一个 piece 是 suffix

piece 的信息太少了, 无法得知 marker 信息, 而如果在这里使用加深层级的方式来表示他们是一个整体, 那么扁平化的意义就不复存在了

不够优雅, 无法容忍自己花大功夫重构, 结果效果比重构前更差

其实 fence 本身就是扁平化 vNode 的结果, 何必纠结扁平化呢

那么就结合之前的架构和思路, 重构为 canvas 渲染如何
